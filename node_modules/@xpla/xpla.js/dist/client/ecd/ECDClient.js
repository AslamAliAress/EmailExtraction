"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ECDClient = void 0;
var APIRequester_1 = require("./APIRequester");
var api_1 = require("./api");
var EvmWallet_1 = require("./EvmWallet");
var numeric_1 = require("../../core/numeric");
var eip55_1 = require("eip55");
var DEFAULT_ECD_OPTIONS = {};
/**
 * An object repesenting a connection to a xplad node running the Lite Client Daemon (LCD)
 * server, a REST server providing access to a node.
 *
 * ### Example
 *
 * ```ts
 * import { ECDClient, Coin } from 'xpla.js';
 *
 * const xpla = new ECDClient({
 *    URL: "https://cube-evm-rpc.xpla.dev",
 *    chainID: "cube_47-5",
 *    id: ECDClient.getIDfromChainID("cube_47-5")
 * });
 * ```
 */
var ECDClient = /** @class */ (function () {
    /**
     * Creates a new EVM client with the specified configuration.
     *
     * @param config ECD configuration
     */
    function ECDClient(config) {
        this.config = __assign(__assign({}, DEFAULT_ECD_OPTIONS), config);
        this.apiRequester = new APIRequester_1.EVMRequester(this.config.URL);
        // instantiate APIs
        this.auth = new api_1.EvmAuthAPI(this);
        this.bank = new api_1.EvmBankAPI(this);
        this.token = new api_1.EvmTokenAPI(this);
        this.nft = new api_1.EvmNftAPI(this);
        this.tx = new api_1.EvmTxAPI(this);
    }
    ECDClient.getIDfromChainID = function (chainID) {
        var tok = chainID.split(/[_-]/g);
        return parseInt(tok[1]);
    };
    ECDClient.bufferFromHex = function (hex) {
        if (hex === undefined || hex === '0x' || hex === '0x0' || hex === '0x00') {
            return Buffer.alloc(0);
        }
        if (hex.startsWith('0x')) {
            hex = hex.substring(2);
        }
        if (hex.length % 2 == 1) {
            hex = '0' + hex;
        }
        return Buffer.from(hex, 'hex');
    };
    ECDClient.unpadBuffer = function (d) {
        var i = 0;
        while (d[i] == 0 && i < d.length)
            i++;
        return d.slice(i);
    };
    ECDClient.bufferToAddress = function (buffer) {
        if (buffer.length < 20)
            throw new Error('Buffer length must be 20');
        else if (buffer.length > 20)
            buffer = buffer.slice(buffer.length - 20, buffer.length);
        return (0, eip55_1.encode)('0x' + buffer.toString('hex'));
    };
    ECDClient.bufferFromString = function (utf8) {
        var result = [];
        for (var i = 0; i < utf8.length; i += 1) {
            var hi = utf8.charCodeAt(i);
            if (hi < 0x0080) {
                // code point range: U+0000 - U+007F
                // bytes: 0xxxxxxx
                result.push(hi);
                continue;
            }
            if (hi < 0x0800) {
                // code point range: U+0080 - U+07FF
                // bytes: 110xxxxx 10xxxxxx
                result.push(0xc0 | (hi >> 6), 0x80 | (hi & 0x3f));
                continue;
            }
            if (hi < 0xd800 || hi >= 0xe000) {
                // code point range: U+0800 - U+FFFF
                // bytes: 1110xxxx 10xxxxxx 10xxxxxx
                result.push(0xe0 | (hi >> 12), 0x80 | ((hi >> 6) & 0x3f), 0x80 | (hi & 0x3f));
                continue;
            }
            i += 1;
            if (i < utf8.length) {
                // surrogate pair
                var lo = utf8.charCodeAt(i);
                var code = ((0x00010000 + (hi & 0x03ff)) << 10) | (lo & 0x03ff);
                // code point range: U+10000 - U+10FFFF
                // bytes: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                result.push(0xf0 | (code >> 18), 0x80 | ((code >> 12) & 0x3f), 0x80 | ((code >> 6) & 0x3f), 0x80 | (code & 0x3f));
            }
            else {
                break;
            }
        }
        return Buffer.from(result);
    };
    ECDClient.dataFromParams = function (types, params) {
        if (types.length > params.length)
            throw new Error('The params count should be more or equal than types.');
        var data = [];
        var dyndata = [];
        var idx = 0;
        var dynoffset = types.length * 32;
        for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {
            var type = types_1[_i];
            var param = params[idx];
            try {
                switch (type) {
                    case 'number':
                        {
                            var hex = void 0;
                            if (typeof param === 'string' && param.startsWith('0x')) {
                                hex = param.substring(2);
                            }
                            else {
                                hex = parseInt(param).toString(16);
                            }
                            if (hex.startsWith('0x')) {
                                hex = hex.substring(2);
                            }
                            if (hex.length % 2 == 1) {
                                hex = '0' + hex;
                            }
                            var buff = Buffer.from(hex, 'hex');
                            if (buff.length < 32) {
                                var pad = Buffer.alloc(32 - buff.length, 0);
                                data.push(pad);
                            }
                            data.push(buff);
                        }
                        break;
                    case 'bignumber':
                    case 'address':
                        {
                            var hex = numeric_1.Numeric.parse(param).toHex();
                            if (hex.startsWith('0x')) {
                                hex = hex.substring(2);
                            }
                            if (hex.length % 2 == 1) {
                                hex = '0' + hex;
                            }
                            var buff = Buffer.from(hex, 'hex');
                            if (buff.length < 32) {
                                var pad = Buffer.alloc(32 - buff.length, 0);
                                data.push(pad);
                            }
                            data.push(buff);
                        }
                        break;
                    case 'bool':
                        {
                            var buff = Buffer.alloc(32, 0);
                            if (param)
                                buff[31] = 1;
                            data.push(buff);
                        }
                        break;
                    case 'string':
                        {
                            if (typeof param !== 'string') {
                                throw new Error('not string');
                            }
                            var pos = dynoffset.toString(16);
                            {
                                var buff_1 = Buffer.from(pos, 'hex');
                                if (buff_1.length < 32) {
                                    var pad = Buffer.alloc(32 - buff_1.length, 0);
                                    data.push(pad);
                                }
                                data.push(buff_1);
                            }
                            var len = param.length.toString(16);
                            {
                                var buff_2 = Buffer.from(len, 'hex');
                                if (buff_2.length < 32) {
                                    var pad = Buffer.alloc(32 - buff_2.length, 0);
                                    dyndata.push(pad);
                                }
                                dyndata.push(buff_2);
                                dynoffset += 32;
                            }
                            var buff = ECDClient.bufferFromString(param);
                            dyndata.push(buff);
                            dynoffset += buff.length;
                            if (buff.length % 32 > 0) {
                                var pad = Buffer.alloc(32 - (buff.length % 32), 0);
                                dyndata.push(pad);
                                dynoffset += pad.length;
                            }
                        }
                        break;
                    case 'bytes':
                        {
                            var bytes = void 0;
                            if (typeof param === 'string' && param.startsWith('0x')) {
                                bytes = Buffer.from(param.substring(2), 'hex');
                            }
                            else if (!(param instanceof Buffer)) {
                                throw new Error('not buffer');
                            }
                            else {
                                bytes = param;
                            }
                            var pos = dynoffset.toString(16);
                            {
                                var buff = Buffer.from(pos, 'hex');
                                if (buff.length < 32) {
                                    var pad = Buffer.alloc(32 - buff.length, 0);
                                    data.push(pad);
                                }
                                data.push(buff);
                            }
                            var len = bytes.length.toString(16);
                            {
                                var buff = Buffer.from(len, 'hex');
                                if (buff.length < 32) {
                                    var pad = Buffer.alloc(32 - buff.length, 0);
                                    dyndata.push(pad);
                                }
                                dyndata.push(buff);
                                dynoffset += 32;
                            }
                            dyndata.push(bytes);
                            dynoffset += bytes.length;
                            if (bytes.length % 32 > 0) {
                                var pad = Buffer.alloc(32 - (bytes.length % 32), 0);
                                dyndata.push(pad);
                                dynoffset += pad.length;
                            }
                        }
                        break;
                    default:
                        break;
                }
            }
            catch (e) {
                var message = 'Unknown Error';
                if (e instanceof Error)
                    message = e.message;
                throw new Error('Cannot parse params: ' + idx + ' type ' + type + '\n' + message);
            }
            ++idx;
        }
        return Buffer.concat(data.concat(dyndata));
    };
    ECDClient.dataToParams = function (types, data) {
        var params = [];
        var idx = 0;
        for (var _i = 0, types_2 = types; _i < types_2.length; _i++) {
            var type = types_2[_i];
            var buff = data.slice(idx, idx + 32);
            try {
                switch (type) {
                    case 'number':
                        {
                            var n = parseInt(buff.toString('hex'), 16);
                            params.push(n);
                        }
                        break;
                    case 'bignumber':
                        {
                            var bn = numeric_1.Numeric.parse('0x' + buff.toString('hex'));
                            params.push(bn);
                        }
                        break;
                    case 'address':
                        {
                            var addr = ECDClient.bufferToAddress(buff);
                            params.push(addr);
                        }
                        break;
                    case 'bool':
                        {
                            var n = parseInt(buff.toString('hex'), 16);
                            params.push(n != 0);
                        }
                        break;
                    case 'string':
                        {
                            var pos = parseInt(buff.toString('hex'), 16);
                            var len = parseInt(data.slice(pos, pos + 32).toString('hex'), 16);
                            var str = data.slice(pos + 32, pos + 32 + len).toString('utf8');
                            params.push(str);
                        }
                        break;
                    case 'bytes':
                        {
                            var pos = parseInt(buff.toString('hex'), 16);
                            var len = parseInt(data.slice(pos, pos + 32).toString('hex'), 16);
                            var buf = Buffer.from(data.slice(pos + 32, pos + 32 + len));
                            params.push(buf);
                        }
                        break;
                    default:
                        break;
                }
            }
            catch (e) {
                var message = 'Unknown Error';
                if (e instanceof Error)
                    message = e.message;
                idx /= 32;
                throw new Error('Cannot parse params: ' + idx + ' type ' + type + '\n' + message);
            }
            idx += 32;
        }
        return params;
    };
    /** Creates a new wallet with the Key. */
    ECDClient.prototype.wallet = function (key) {
        key.evm = true;
        return new EvmWallet_1.EvmWallet(this, key);
    };
    ECDClient.prototype.info = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var info = {
                            clientVersion: null,
                            netVersion: null,
                            netListening: null,
                            peerCount: null,
                            protocolVersion: null,
                            syncing: null,
                            mining: null,
                            hashrate: 0,
                            gasPrice: 0,
                            blockNumber: 0,
                        };
                        _this.apiRequester
                            .post(_this.config.id, 'web3_clientVersion', [])
                            .then(function (response) {
                            if (_this.apiRequester.isError(response)) {
                                throw _this.apiRequester.getError(response);
                            }
                            info.clientVersion = response.result;
                            return _this.apiRequester.post(_this.config.id, 'net_version', []);
                        })
                            .then(function (response) {
                            if (_this.apiRequester.isError(response)) {
                                throw _this.apiRequester.getError(response);
                            }
                            info.netVersion = response.result;
                            return _this.apiRequester.post(_this.config.id, 'net_listening', []);
                        })
                            .then(function (response) {
                            if (_this.apiRequester.isError(response)) {
                                throw _this.apiRequester.getError(response);
                            }
                            info.netListening = response.result;
                            return _this.apiRequester.post(_this.config.id, 'net_peerCount', []);
                        })
                            .then(function (response) {
                            if (_this.apiRequester.isError(response)) {
                                throw _this.apiRequester.getError(response);
                            }
                            info.peerCount = response.result;
                            return _this.apiRequester.post(_this.config.id, 'eth_protocolVersion', []);
                        })
                            .then(function (response) {
                            if (_this.apiRequester.isError(response)) {
                                throw _this.apiRequester.getError(response);
                            }
                            info.protocolVersion = response.result;
                            return _this.apiRequester.post(_this.config.id, 'eth_syncing', []);
                        })
                            .then(function (response) {
                            if (_this.apiRequester.isError(response)) {
                                throw _this.apiRequester.getError(response);
                            }
                            info.syncing = response.result;
                            return _this.apiRequester.post(_this.config.id, 'eth_mining', []);
                        })
                            .then(function (response) {
                            if (_this.apiRequester.isError(response)) {
                                throw _this.apiRequester.getError(response);
                            }
                            info.mining = response.result;
                            return _this.apiRequester.post(_this.config.id, 'eth_hashrate', []);
                        })
                            .then(function (response) {
                            if (_this.apiRequester.isError(response)) {
                                throw _this.apiRequester.getError(response);
                            }
                            info.hashrate = parseInt(response.result, 16);
                            return _this.apiRequester.post(_this.config.id, 'eth_gasPrice', []);
                        })
                            .then(function (response) {
                            if (_this.apiRequester.isError(response)) {
                                throw _this.apiRequester.getError(response);
                            }
                            info.gasPrice = parseInt(response.result, 16);
                            return _this.apiRequester.post(_this.config.id, 'eth_blockNumber', []);
                        })
                            .then(function (response) {
                            if (_this.apiRequester.isError(response)) {
                                throw _this.apiRequester.getError(response);
                            }
                            info.blockNumber = parseInt(response.result, 16);
                            resolve(info);
                        })
                            .catch(function (error) {
                            reject(error);
                        });
                    })];
            });
        });
    };
    return ECDClient;
}());
exports.ECDClient = ECDClient;
//# sourceMappingURL=ECDClient.js.map