"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmTxAPI = void 0;
var BaseAPI_1 = require("./BaseAPI");
var EvmTx_1 = require("../msgs/EvmTx");
var core_1 = require("../../../core");
var ECDClient_1 = require("../ECDClient");
var rlp_1 = __importDefault(require("rlp"));
var keccak256_1 = require("@ethersproject/keccak256");
var secp256k1 = __importStar(require("secp256k1"));
var EvmTxAPI = /** @class */ (function (_super) {
    __extends(EvmTxAPI, _super);
    function EvmTxAPI(ecd) {
        var _this = _super.call(this, ecd.apiRequester) || this;
        _this.ecd = ecd;
        return _this;
    }
    EvmTxAPI.prototype.get = function (hash) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.e
                        .post(this.ecd.config.id, 'eth_getTransactionByHash', [hash])
                        .then(function (response) {
                        if (_this.e.isError(response)) {
                            throw _this.e.getError(response);
                        }
                        return _this.fromParams(response.result);
                    })];
            });
        });
    };
    EvmTxAPI.prototype.toParams = function (tx) {
        var params = {};
        if (tx.chainId)
            params.chainId = core_1.Numeric.parse(tx.chainId).toHex();
        if (tx.blockHash)
            params.blockHash = tx.blockHash;
        if (tx.blockNumber)
            params.blockNumber = core_1.Numeric.parse(tx.blockNumber).toHex();
        if (tx.from)
            params.from = tx.from;
        if (tx.gasLimit)
            params.gasLimit = core_1.Numeric.parse(tx.gasLimit).toHex();
        if (tx.gasPrice)
            params.gasPrice = core_1.Numeric.parse(tx.gasPrice).toHex();
        if (tx.hash)
            params.hash = tx.hash;
        if (tx.input)
            params.input = tx.input;
        if (tx.nonce)
            params.nonce = core_1.Numeric.parse(tx.nonce).toHex();
        if (tx.to)
            params.to = tx.to;
        if (tx.transactionIndex)
            params.transactionIndex = core_1.Numeric.parse(tx.transactionIndex).toHex();
        if (tx.value)
            params.value = core_1.Numeric.parse(tx.value).toHex();
        if (tx.data)
            params.data = '0x' + Buffer.from(tx.data).toString('hex');
        if (tx.type)
            params.type = core_1.Numeric.parse(tx.type).toHex();
        if (tx.v)
            params.v = core_1.Numeric.parse(tx.v).toHex();
        if (tx.r)
            params.r = '0x' + Buffer.from(tx.r).toString('hex');
        if (tx.s)
            params.s = '0x' + Buffer.from(tx.s).toString('hex');
        if (tx.accessList)
            params.accessList = tx.accessList;
        return params;
    };
    EvmTxAPI.prototype.fromParams = function (params) {
        var tx = {};
        if (params.chainId)
            tx.chainId = core_1.Numeric.parse(params.chainId).toNumber();
        if (params.blockHash)
            tx.blockHash = params.blockHash;
        if (params.blockNumber)
            tx.blockNumber = core_1.Numeric.parse(params.blockNumber);
        if (params.from)
            tx.from = params.from;
        if (params.gasLimit)
            tx.gasLimit = core_1.Numeric.parse(params.gasLimit);
        if (params.gasPrice)
            tx.gasPrice = core_1.Numeric.parse(params.gasPrice);
        if (params.hash)
            tx.hash = params.hash;
        if (params.input)
            tx.input = params.input;
        if (params.nonce)
            tx.nonce = core_1.Numeric.parse(params.nonce);
        if (params.to)
            tx.to = params.to;
        if (params.transactionIndex)
            tx.transactionIndex = core_1.Numeric.parse(params.transactionIndex);
        if (params.value)
            tx.value = core_1.Numeric.parse(params.value);
        if (params.data)
            tx.data = Buffer.from(params.data.indexOf('0x') == 0 ? params.data.substring(2) : params.data, 'hex');
        if (params.type)
            tx.type = core_1.Numeric.parse(params.type).toNumber();
        if (params.v)
            tx.v = core_1.Numeric.parse(params.v).toNumber();
        if (params.r)
            tx.r = Buffer.from(params.r.indexOf('0x') == 0 ? params.r.substring(2) : params.r, 'hex');
        if (params.s)
            tx.s = Buffer.from(params.s.indexOf('0x') == 0 ? params.s.substring(2) : params.s, 'hex');
        if (tx.accessList)
            params.accessList = tx.accessList;
        return tx;
    };
    EvmTxAPI.prototype.create = function (by, options) {
        return __awaiter(this, void 0, void 0, function () {
            var msg, utx, _a, _b, _c, gasPrices, _d, _e, _f, _g;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        msg = options.msgs[0];
                        utx = msg.tx();
                        if (utx.chainId == undefined) {
                            utx.chainId = this.ecd.config.id;
                        }
                        if (!(utx.gasLimit == undefined)) return [3 /*break*/, 3];
                        if (!options.gasLimit) return [3 /*break*/, 1];
                        utx.gasLimit = core_1.Numeric.parse(options.gasLimit);
                        return [3 /*break*/, 3];
                    case 1:
                        _a = utx;
                        _c = (_b = core_1.Numeric).parse;
                        return [4 /*yield*/, this.estimateGas(utx)];
                    case 2:
                        _a.gasLimit = _c.apply(_b, [_h.sent()]);
                        _h.label = 3;
                    case 3:
                        if (!(utx.gasPrice == undefined)) return [3 /*break*/, 6];
                        if (!options.gasPrice) return [3 /*break*/, 4];
                        utx.gasPrice = core_1.Numeric.parse(options.gasPrice);
                        return [3 /*break*/, 6];
                    case 4: return [4 /*yield*/, this.getGasPrices()];
                    case 5:
                        gasPrices = _h.sent();
                        utx.gasPrice = core_1.Numeric.parse(gasPrices['axpla']);
                        _h.label = 6;
                    case 6:
                        if (!(utx.nonce == undefined)) return [3 /*break*/, 10];
                        _d = utx;
                        if (!options.sequence) return [3 /*break*/, 7];
                        _e = core_1.Numeric.parse(options.sequence);
                        return [3 /*break*/, 9];
                    case 7:
                        _g = (_f = core_1.Numeric).parse;
                        return [4 /*yield*/, this.ecd.auth.accountInfo(by)];
                    case 8:
                        _e = _g.apply(_f, [(_h.sent()).getSequenceNumber()]);
                        _h.label = 9;
                    case 9:
                        _d.nonce = _e;
                        _h.label = 10;
                    case 10: return [2 /*return*/, utx];
                }
            });
        });
    };
    EvmTxAPI.prototype.getGasPrices = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.e
                            .post(_this.ecd.config.id, 'eth_gasPrice', [])
                            .then(function (response) {
                            if (_this.e.isError(response)) {
                                throw _this.e.getError(response);
                            }
                            resolve({
                                axpla: core_1.Numeric.parse(response.result).toString(),
                            });
                        })
                            .catch(function (error) {
                            reject(error);
                        });
                    })];
            });
        });
    };
    EvmTxAPI.prototype.estimateGas = function (tx) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.e
                        .post(this.ecd.config.id, 'eth_estimateGas', [this.toParams(tx)])
                        .then(function (response) {
                        if (_this.e.isError(response)) {
                            throw _this.e.getError(response);
                        }
                        return core_1.Numeric.parse(response.result).toString();
                    })];
            });
        });
    };
    EvmTxAPI.prototype._broadcast = function (tx) {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function () {
            var chainId, v, params, v_id, values, serializedMsg, response;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        chainId = tx.chainId, v = tx.v;
                        params = this.toParams(tx);
                        v_id = chainId && v
                            ? BigInt(chainId) * BigInt(2) + BigInt(35 + v - 27)
                            : BigInt(0);
                        values = [
                            ECDClient_1.ECDClient.bufferFromHex((_a = params.nonce) !== null && _a !== void 0 ? _a : '0'),
                            ECDClient_1.ECDClient.bufferFromHex((_b = params.gasPrice) !== null && _b !== void 0 ? _b : '0'),
                            ECDClient_1.ECDClient.bufferFromHex((_c = params.gasLimit) !== null && _c !== void 0 ? _c : '0'),
                            ECDClient_1.ECDClient.unpadBuffer(ECDClient_1.ECDClient.bufferFromHex(params.to)),
                            ECDClient_1.ECDClient.bufferFromHex((_d = params.value) !== null && _d !== void 0 ? _d : '0'),
                            ECDClient_1.ECDClient.unpadBuffer((_e = tx.data) !== null && _e !== void 0 ? _e : Buffer.alloc(0)),
                            ECDClient_1.ECDClient.bufferFromHex(v_id.toString(16)),
                            ECDClient_1.ECDClient.unpadBuffer((_f = tx.r) !== null && _f !== void 0 ? _f : Buffer.alloc(0)),
                            ECDClient_1.ECDClient.unpadBuffer((_g = tx.s) !== null && _g !== void 0 ? _g : Buffer.alloc(0)),
                        ];
                        serializedMsg = '0x' + Buffer.from(rlp_1.default.encode(values)).toString('hex');
                        return [4 /*yield*/, this.e.post(this.ecd.config.id, 'eth_sendRawTransaction', [serializedMsg])];
                    case 1:
                        response = _h.sent();
                        return [2 /*return*/, response];
                }
            });
        });
    };
    /**
     * Broadcast the transaction using "sync" mode, then wait for its inclusion in a block.
     *
     * This method polls txInfo using the txHash to confirm the transaction's execution.
     *
     * @param tx      transaction to broadcast
     * @param timeout time in milliseconds to wait for transaction to be included in a block. defaults to 30000
     */
    EvmTxAPI.prototype.broadcast = function (tx, timeout) {
        if (timeout === void 0) { timeout = 30000; }
        return __awaiter(this, void 0, void 0, function () {
            var POLL_INTERVAL, response, hash, result, i, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        POLL_INTERVAL = 500;
                        return [4 /*yield*/, this._broadcast(tx)];
                    case 1:
                        response = _a.sent();
                        if (this.e.isError(response)) {
                            throw this.e.getError(response);
                        }
                        hash = response.result;
                        i = 0;
                        _a.label = 2;
                    case 2:
                        if (!(i <= timeout / POLL_INTERVAL)) return [3 /*break*/, 9];
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.txInfo(hash)];
                    case 4:
                        result = _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        error_1 = _a.sent();
                        return [3 /*break*/, 6];
                    case 6:
                        if (result) {
                            return [3 /*break*/, 9];
                        }
                        return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, POLL_INTERVAL); })];
                    case 7:
                        _a.sent();
                        _a.label = 8;
                    case 8:
                        i++;
                        return [3 /*break*/, 2];
                    case 9:
                        if (!result) {
                            throw new Error("Transaction was not included in a block before timeout of ".concat(timeout, "ms"));
                        }
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * NOTE: This is not a synchronous function and is unconventionally named. This function
     * can be await as it returns a `Promise`.
     *
     * Broadcast the transaction using the "sync" mode, returning after CheckTx() is performed.
     * @param tx transaction to broadcast
     */
    EvmTxAPI.prototype.broadcastSync = function (tx) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._broadcast(tx)];
                    case 1:
                        response = _a.sent();
                        if (this.e.isError(response)) {
                            throw this.e.getError(response);
                        }
                        return [2 /*return*/, response.result];
                }
            });
        });
    };
    /**
     * Looks up a transaction on the blockchain, addressed by its hash
     * @param txHash transaction's hash
     */
    EvmTxAPI.prototype.txInfo = function (hash) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.e
                        .post(this.ecd.config.id, 'eth_getTransactionReceipt', [hash])
                        .then(function (response) {
                        if (_this.e.isError(response)) {
                            throw _this.e.getError(response);
                        }
                        return EvmTx_1.EvmTxInfo.fromData(response.result);
                    })];
            });
        });
    };
    EvmTxAPI.prototype.sign = function (signer, tx) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var privateKey, params, values, rlp, msgHash, sig, r, s, v;
            return __generator(this, function (_b) {
                if (tx.nonce === undefined ||
                    tx.gasPrice === undefined ||
                    tx.gasLimit === undefined) {
                    throw new Error('tx must have [ nonce, gasLimit, gasPrice ]');
                }
                privateKey = null;
                if (signer.key) {
                    signer = signer.key;
                }
                if (signer.privateKey) {
                    privateKey = signer.privateKey;
                }
                if (privateKey == null) {
                    throw new Error('failed to get private key');
                }
                params = this.toParams(tx);
                values = [
                    params.nonce ? ECDClient_1.ECDClient.bufferFromHex(params.nonce) : Buffer.alloc(0),
                    params.gasPrice
                        ? ECDClient_1.ECDClient.bufferFromHex(params.gasPrice)
                        : Buffer.alloc(0),
                    params.gasLimit
                        ? ECDClient_1.ECDClient.bufferFromHex(params.gasLimit)
                        : Buffer.alloc(0),
                    ECDClient_1.ECDClient.unpadBuffer(ECDClient_1.ECDClient.bufferFromHex(params.to)),
                    params.value ? ECDClient_1.ECDClient.bufferFromHex(params.value) : Buffer.alloc(0),
                    ECDClient_1.ECDClient.unpadBuffer((_a = tx.data) !== null && _a !== void 0 ? _a : Buffer.alloc(0)),
                    params.chainId
                        ? ECDClient_1.ECDClient.bufferFromHex(params.chainId)
                        : Buffer.alloc(0),
                    Buffer.alloc(0),
                    Buffer.alloc(0),
                ];
                rlp = rlp_1.default.encode(values);
                msgHash = (0, keccak256_1.keccak256)(rlp);
                sig = secp256k1.ecdsaSign(Buffer.from(msgHash.substring(2), 'hex'), privateKey);
                r = sig.signature.slice(0, 32);
                s = sig.signature.slice(32, 64);
                v = sig.recid ? 0x1c : 0x1b;
                tx.v = v;
                tx.r = Buffer.from(r);
                tx.s = Buffer.from(s);
                return [2 /*return*/, tx];
            });
        });
    };
    return EvmTxAPI;
}(BaseAPI_1.EvmAPI));
exports.EvmTxAPI = EvmTxAPI;
//# sourceMappingURL=TxAPI.js.map