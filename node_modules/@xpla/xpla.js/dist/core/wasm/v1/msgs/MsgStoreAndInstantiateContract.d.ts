import { JSONSerializable } from '../../../../util/json';
import { AccAddress } from '../../../bech32';
import { Coins } from '../../../Coins';
import { AccessConfig } from '../AccessConfig';
import { Any } from '@xpla/xpla.proto/google/protobuf/any';
import { MsgStoreAndInstantiateContract as MsgStoreAndInstantiateContractV1_pb } from '@xpla/xpla.proto/cosmwasm/wasm/v1/tx';
export declare class MsgStoreAndInstantiateContractV1 extends JSONSerializable<MsgStoreAndInstantiateContractV1.Amino, MsgStoreAndInstantiateContractV1.Data, MsgStoreAndInstantiateContractV1.Proto> {
    authority: AccAddress;
    wasm_byte_code: string;
    instantiate_permission: AccessConfig | undefined;
    unpin_code: boolean;
    admin: AccAddress;
    label: string;
    msg: object | string;
    source: string;
    builder: string;
    code_hash: string;
    funds: Coins;
    /**
     * @param authority is the address of the governance account
     * @param wasm_byte_code base64-encoded bytecode contents
     * @param instantiate_permission to apply on contract creation, optional
     * @param unpin_code code on upload, optional. As default the uploaded contract is pinned to cache
     * @param admin is an optional address that can execute migrations
     * @param label is metadata to be stored with a constract instance
     * @param msg json encoded message to be passed to the contract on instantiation
     * @param funds coins that are transferred from the authority account to the contract on instantiation
     * @param source is the URL where the code is hosted
     * @param builder is the docker image used to build the code deterministically, used for smart contract verification
     * @param code_hash is the SHA256 sum of the code outputted by builder, used for smart contract verification
     */
    constructor(authority: AccAddress, wasm_byte_code: string, instantiate_permission: AccessConfig | undefined, unpin_code: boolean, admin: AccAddress, label: string, msg: object | string, funds: Coins.Input | undefined, source: string, builder: string, code_hash: string);
    static fromAmino(data: MsgStoreAndInstantiateContractV1.Amino, _isClassic?: boolean): MsgStoreAndInstantiateContractV1;
    toAmino(_isClassic?: boolean): MsgStoreAndInstantiateContractV1.Amino;
    static fromProto(proto: MsgStoreAndInstantiateContractV1.Proto, _isClassic?: boolean): MsgStoreAndInstantiateContractV1;
    toProto(_isClassic?: boolean): MsgStoreAndInstantiateContractV1.Proto;
    packAny(isClassic?: boolean): Any;
    static unpackAny(msgAny: Any, isClassic?: boolean): MsgStoreAndInstantiateContractV1;
    static fromData(data: MsgStoreAndInstantiateContractV1.Data, _isClassic?: boolean): MsgStoreAndInstantiateContractV1;
    toData(_isClassic?: boolean): MsgStoreAndInstantiateContractV1.Data;
}
export declare namespace MsgStoreAndInstantiateContractV1 {
    interface Amino {
        type: 'wasm/MsgStoreAndInstantiateContract';
        value: {
            authority: AccAddress;
            wasm_byte_code: string;
            instantiate_permission: AccessConfig.Data | undefined;
            unpin_code: boolean;
            admin: AccAddress;
            label: string;
            msg: object | string;
            funds: Coins.Data;
            source: string;
            builder: string;
            code_hash: string;
        };
    }
    interface Data {
        '@type': '/cosmwasm.wasm.v1.MsgStoreAndInstantiateContract';
        authority: AccAddress;
        wasm_byte_code: string;
        instantiate_permission: AccessConfig.Data | undefined;
        unpin_code: boolean;
        admin: AccAddress;
        label: string;
        msg: object | string;
        funds: Coins.Data;
        source: string;
        builder: string;
        code_hash: string;
    }
    type Proto = MsgStoreAndInstantiateContractV1_pb;
}
